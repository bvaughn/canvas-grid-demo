<html>
<head>
<style>
  body {
    background: #ddd;
    padding: 0;
    margin: 0;
  }

  #positioner {
    position: relative;
  }

  #scroller {
    overflow: auto;
    position: absolute;
    top: 0;
    left: 0;
    touch-action: pan-x pan-y;
    outline: none;
  }

  #canvas {
    position: absolute;
    top: 0;
    left: 0;
    background: #fff;
  }

  #activeCellInput {
    position: absolute;
    text-align: right;
  }
</style>
</head>
<body>

<div id="positioner">
  <canvas id="canvas"></canvas>

  <div id="scroller">
    <div id="sizer"></div>
  </div>

  <input id="activeCellInput" type="text" />
</div>

<script src="./utils.js"></script>
<script>
  const columnHeaders = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

  const STYLES = {
    background: {
      default: '#fff',
      fixedRow: '#f8f9fa',
      focused: '#e9effd',
      selected: '#e9effd',
      selectedFixed: '#d3e3fe',
    },
    border: {
      default: '#e1e1e1',
      fixedColumn: '#c0c0c0',
      fixedRow: '#c0c0c0',
      focused: '#1b73e8',
      selected: '#1b73e8',
    },
    fonts: {
      default: '10px sans-serif',
      fixedColumn: '8px sans-serif',
      fixedColumnSelected: '8px sans-serif bold',
      fixedRow: '10px sans-serif',
      fixedRowSelected: '10px sans-serif bold',
    },
    text: {
      default: '#333',
      fixedColumn: '#888',
    },
  };

  let width = 800;
  let height = 400;

  const cellPadding = 4;
  const focusedCellOffset = 2;

  const activeCellInput = document.getElementById('activeCellInput');
  const scroller = document.getElementById('scroller');
  const canvas = document.getElementById('canvas');
  const context = canvas.getContext("2d");

  function scaleHelper() {
    const dpr = window.devicePixelRatio || 2

    const { width, height } = canvas.getBoundingClientRect()

    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
      canvas.width = width * dpr;
      canvas.height = height * dpr;
    }

    // Reset scale to identical matrix to allow multiple re-scales.
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.scale(dpr, dpr);
  }

  function resize() {
    height = window.innerHeight;
    width = window.innerWidth;

    canvas.style.height = `${height}px`
    canvas.style.width = `${width}px`;

    scroller.style.height = `${height}px`
    scroller.style.width = `${width}px`;

    scaleHelper();
  }

  resize();

  // TODO Handle resize

  function draw(grid) {
    const {
      activeCell,
      activeCellRect,
      focusedCell,
      getCellAtPosition,
      getCellData,
      getCellRect,
      numCols,
      numRows,
      offsetX,
      offsetY,
      selection
    } = grid;

    context.clearRect(0, 0, width, height);

    const modifyRectForOffsets = (rect) => {
      rect.x -= offsetX;
      rect.y -= offsetY;
      return rect;
    };

    const getColumnHeader = (columnIndex) => {
      let label = "";

      while (columnIndex >= 0) {
        label += columnHeaders[columnIndex % columnHeaders.length];

        columnIndex -= columnHeaders.length;
      }

      return label;
    };

    // TODO Only draw visible cells (requires tracking offsets)
    const topLeftCell = getCellAtPosition(offsetX, offsetY, true);
    const bottomRightCell = getCellAtPosition(offsetX + width, offsetY + height, true);
    const visibleBounds = {
      start: {
        columnIndex: topLeftCell.columnIndex,
        rowIndex: topLeftCell.rowIndex
      },
      stop: {
        columnIndex: bottomRightCell.columnIndex,
        rowIndex: bottomRightCell.rowIndex
      }
    };

    // Draw data cells
    for (
      let columnIndex = visibleBounds.start.columnIndex;
      columnIndex <= visibleBounds.stop.columnIndex;
      columnIndex++
    ) {
      for (
        let rowIndex = visibleBounds.start.rowIndex;
        rowIndex <= visibleBounds.stop.rowIndex;
        rowIndex++
      ) {
        const isSelected = selection && (
          rowIndex >= selection.start.rowIndex &&
          rowIndex <= selection.stop.rowIndex &&
          columnIndex >= selection.start.columnIndex &&
          columnIndex <= selection.stop.columnIndex
        );

        drawDataCell({
          columnIndex,
          context,
          mode: isSelected ? "selected" : "view",
          rect: modifyRectForOffsets(getCellRect(rowIndex, columnIndex)),
          rowIndex,
          text: getCellData(rowIndex, columnIndex),
        });
      }
    }

    // Draw selection outline above base grid
    if (selection) {
      const topLeftCell = modifyRectForOffsets(getCellRect(selection.start.rowIndex, selection.start.columnIndex));
      const bottomRightCell = modifyRectForOffsets(getCellRect(selection.stop.rowIndex, selection.stop.columnIndex));

      drawRect({
        context,
        rect: {
          height: bottomRightCell.y + bottomRightCell.height - topLeftCell.y,
          width: bottomRightCell.x + bottomRightCell.width - topLeftCell.x,
          x: topLeftCell.x,
          y: topLeftCell.y,
        },
        strokeStyle: STYLES.border.selected,
      });
    }

    // Draw focused cell on top of everything else
    if (focusedCell) {
      const { columnIndex, rowIndex } = focusedCell;
      const rect = modifyRectForOffsets(getCellRect(rowIndex, columnIndex));

      drawRect({
        context,
        rect: {
          height: rect.height,
          width: rect.width,
          x: rect.x,
          y: rect.y,
        },
        strokeStyle: STYLES.border.focused,
      });
    }

    // Draw fixed row headers
    for (
      let columnIndex = visibleBounds.start.columnIndex;
      columnIndex <= visibleBounds.stop.columnIndex;
      columnIndex++
    ) {
      drawFixedHeaderRow({
        context,
        isSelected: selection && selection.start.columnIndex <= columnIndex && selection.stop.columnIndex >= columnIndex,
        rect: {
          ...modifyRectForOffsets(getCellRect(-1, columnIndex)),
          y: 0,
        },
        text: columnIndex >= 0 ? getColumnHeader(columnIndex) : "",
      });
    }

    // Draw fixed column labels
    for (
      let rowIndex = visibleBounds.start.rowIndex;
      rowIndex <= visibleBounds.stop.rowIndex;
      rowIndex++
    ) {
      drawFixedColumnNumber({
        context,
        isSelected: selection && selection.start.rowIndex <= rowIndex && selection.stop.rowIndex >= rowIndex,
        rect: {
          ...modifyRectForOffsets(getCellRect(rowIndex, -1)),
          x: 0
        },
        text: rowIndex,
      });
    }

    if (activeCell && activeCellRect) {
      activeCellInput.style.display = 'block';
      activeCellInput.style.font = STYLES.fonts.default;
      activeCellInput.style.left = `${activeCellRect.x}px`;
      activeCellInput.style.top = `${activeCellRect.y}px`;
      activeCellInput.style.height = `${activeCellRect.height}px`;
      activeCellInput.style.width = `${activeCellRect.width}px`;
      activeCellInput.value = getCellData(activeCell.rowIndex, activeCell.columnIndex);
    } else {
      activeCellInput.style.display = 'none';
    }

    drawRect({
      context,
      fillStyle: STYLES.background.fixedRow,
      rect: getCellRect(-1, -1),
      strokeSides: STROKE_SIDE_BOTTOM | STROKE_SIDE_RIGHT,
      strokeStyle: STYLES.border.fixedRow,
    });
  }

  function drawFixedColumnNumber({ context, isSelected, rect, text }) {
    drawRect({
      context,
      fillStyle: isSelected ? STYLES.background.selectedFixed : STYLES.background.default,
      rect,
      strokeSides: STROKE_SIDE_BOTTOM | STROKE_SIDE_RIGHT,
      strokeStyle: STYLES.border.fixedColumn,
    })

    fillTextHelper({
      context,
      fillStyle: STYLES.text.default,
      font: isSelected ? STYLES.fonts.fixedColumnSelected : STYLES.fonts.fixedColumn,
      padding: cellPadding,
      rect,
      text,
      textAlign: 'center',
    });
  }

  function drawFixedHeaderRow({ context, isSelected, rect, text }) {
    drawRect({
      context,
      fillStyle: isSelected ? STYLES.background.selectedFixed : STYLES.background.fixedRow,
      lineWidth: 1,
      rect,
      strokeSides: STROKE_SIDE_BOTTOM | STROKE_SIDE_RIGHT,
      strokeStyle: STYLES.border.fixedRow,
    });

    fillTextHelper({
      context,
      font: isSelected ? STYLES.fonts.fixedRowSelected : STYLES.fonts.fixedRow,
      padding: cellPadding,
      rect,
      text,
      textAlign: 'center',
    });
  }

  function drawDataCell({ columnIndex, context, mode, rect, rowIndex, text }) {
    let fillStyle;
    let lineWidth;
    let strokeStyle;

    switch (mode) {
      case 'focused': {
        fillStyle = STYLES.background.focused;
        lineWidth = 2;
        strokeStyle = STYLES.border.focused;
        break;
      }
      case 'selected': {
        fillStyle = STYLES.background.selected;
        lineWidth = 1;
        strokeStyle = STYLES.border.default;
        break;
      }
      case 'view': {
        fillStyle = STYLES.background.default;
        lineWidth = 1;
        strokeStyle = STYLES.border.default;
        break;
      }
      default: {
        throw `Unsupported mode "${mode}"`;
      }
    }

    drawRect({
      context,
      fillStyle,
      lineWidth,
      rect,
      strokeSides: STROKE_SIDE_BOTTOM | STROKE_SIDE_RIGHT,
      strokeStyle,
    });

    fillTextHelper({
      context,
      padding: cellPadding,
      rect,
      text,
      textAlign: 'right',
    });
  }

  function fillTextHelper({
    textBaseline = "middle",
    context,
    fillStyle = STYLES.text.default,
    font = STYLES.fonts.default,
    padding,
    rect,
    text,
    textAlign,
  }) {
    let {
      height,
      width,
      x,
      y,
    } = rect;

    while (text.length > 0) {
      const { width: measuredWidth } = context.measureText(text);

      if (measuredWidth > width - padding * 2) {
        text = text.substring(0, text.length - 1);
      } else {
        break;
      }
    }

    const verticalCenter = y + height / 2;

    context.font = font;
    context.textBaseline = textBaseline;
    context.fillStyle = fillStyle;

    switch (textAlign) {
      case "center": {
        context.textAlign = "center";
        context.fillText(text, x + width / 2, verticalCenter);
        break;
      }
      case "left": {
        context.textAlign = "left";
        context.fillText(text, x + padding, verticalCenter);
        break;
      }
      case "right": {
        context.textAlign = "right";
        context.fillText(text, x + width - padding, verticalCenter);
        break;
      }
      default: {
        throw `Unsupported alignment "${textAlign}"`;
      }
    }
  }

  {
    // Fake grid data for demo purposes

    const numRows = 10_000;
    const numCols = 100;

    const cellHeight = 20;
    const fixedCellWidth = 20;

    const randomData = new Array(numRows * numCols)
      .fill(true)
      .map(() => Math.round(Math.random() * 10_000));

    const randomCellWidths = new Array(numRows * numCols)
      .fill(true)
      .map(() => 50 + Math.round(Math.random() * 25));

    const totalWidth = new Array(numCols)
      .fill(true)
      .map((_, index) => index)
      .reduce((totalWidth, columnIndex) => {
        const width = randomCellWidths[columnIndex];

        return totalWidth + width;
      }, 0);

    let activeCell = null;
    let activeCellRect = null;
    let firstDragCell = null;
    let mostRecentDragCell = null;

    let offsetX = 0;
    let offsetY = 0;

    let focusedCell = null;
    let pointerMovedAfterDown = false;
    let selection = null;

    const sizer = document.getElementById('sizer');
    sizer.style.height = `${cellHeight * numRows}px`
    sizer.style.width = `${totalWidth}px`;

    activeCellInput.addEventListener('keydown', (event) => {
      switch (event.key) {
        case "Enter":
        case "Tab": {
          confirmPendingEdit(activeCell, activeCellInput.value);
          break;
        }
      }
    })

    // Let the browser manage (elastic) scrolling for us
    scroller.addEventListener('scroll', (event) => {
      event.preventDefault();

      offsetX = scroller.scrollLeft;
      offsetY = scroller.scrollTop;

      redraw();
    });

    // TODO Separate event listeners from user config space
    // TODO Support keyboard navigation also

    scroller.addEventListener('pointerdown', (event) => {
      if (activeCell) {
        confirmPendingEdit(activeCell, activeCellInput.value);
      }

      activeCell = null;
      activeCellRect = null;
      focusedCell = firstDragCell = getCellAtPosition(event.offsetX, event.offsetY);
      pointerMovedAfterDown = false;

      if (focusedCell) {
        selection = {
          start: focusedCell,
          stop: focusedCell,
        };
      }

      redraw();
    });

    scroller.addEventListener('pointermove', (event) => {
      // TODO Update selection when moving outside of canvas (or within fixed cells)

      pointerMovedAfterDown = true;

      if (firstDragCell) {
        const cell = getCellAtPosition(event.offsetX, event.offsetY);
        if (cell) {
          mostRecentDragCell = cell;

          // Re-calculate all selected cells based on start point and current point
          selection = {
            start: {
              columnIndex: Math.min(firstDragCell.columnIndex, mostRecentDragCell.columnIndex),
              rowIndex: Math.min(firstDragCell.rowIndex, mostRecentDragCell.rowIndex)
            },
            stop: {
              columnIndex: Math.max(firstDragCell.columnIndex, mostRecentDragCell.columnIndex),
              rowIndex: Math.max(firstDragCell.rowIndex, mostRecentDragCell.rowIndex)
            },
          };

          redraw();
        }
      }
    });

    window.addEventListener('pointerup', (event) => {
      if (firstDragCell && !pointerMovedAfterDown) {
        activeCell = firstDragCell;

        const rect = getCellRect(activeCell.rowIndex, activeCell.columnIndex);
        activeCellRect = {
          ...rect,
          x: rect.x - offsetX,
          y: rect.y - offsetY,
        };

        activeCellInput.style.display = 'block';
        activeCellInput.focus();

        redraw()
      }

      firstDragCell = null;
      mostRecentDragCell = null;
    });

    function confirmPendingEdit(cell, value) {
      const { columnIndex, rowIndex } = cell;
      const index = rowIndex * numCols + columnIndex;
      randomData[index] = value;

      activeCell = null;
      activeCellRect = null;

      redraw();
    }

    function getCellSize(rowIndex, columnIndex) {
      return {
        height: cellHeight,
        width: columnIndex < 0 ? fixedCellWidth : randomCellWidths[columnIndex]
      };
    }

    function getCellAtPosition(x, y, findNearest) {
      let columnIndex = -1;
      let currentX = 0;
      while (true) {
        const { width } = getCellSize(0, columnIndex);

        currentX += width;

        if (currentX >= x && currentX + width >= x) {
          break;
        } else if (columnIndex === numCols - 1) {
          break;
        }

        columnIndex++;
      }

      const rowIndex = Math.min(numRows - 1, Math.floor(y / cellHeight) - 1);

      if (columnIndex < 0 || rowIndex < 0) {
        if (findNearest) {
          return {
            columnIndex: Math.max(columnIndex, 0),
            rowIndex: Math.max(rowIndex, 0)
          };
        } else {
          return null;
        }
      } else {
        return { columnIndex, rowIndex };
      }
    }

    // TODO Cache computed cell offsets so we don't need to recalculate on every scroll
    function getCellRect(rowIndex, columnIndex) {
      let width = columnIndex < 0 ? fixedCellWidth : randomCellWidths[columnIndex];

      let x = 0;
      for (let prevColumnIndex = -1; prevColumnIndex < columnIndex; prevColumnIndex++) {
        const { width } = getCellSize(0, prevColumnIndex);

        x += width;
      }

      return {
        height: cellHeight,
        width,
        x,
        y: (rowIndex + 1) * cellHeight
      };
    }

    function redraw() {
      draw({
        activeCell,
        activeCellRect,
        getCellRect,
        getCellData: (rowIndex, columnIndex) => {
          const index = rowIndex * numCols + columnIndex;
          return randomData[index];
        },
        getCellAtPosition,
        focusedCell,
        numCols,
        numRows,
        offsetX,
        offsetY,
        selection,
      });
    }

    redraw();
  }
</script>
</body>
</html>