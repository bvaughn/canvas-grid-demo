<html>
<head>
<style>
  body {
    background: #ddd;
    padding: 0;
    margin: 0;
  }

  #positioner {
    position: relative;
  }

  #scroller {
    overflow: auto;
    position: absolute;
    top: 0;
    left: 0;
    touch-action: pan-x pan-y;
    outline: none;
  }

  #canvas {
    position: absolute;
    top: 0;
    left: 0;
    background: #fff;
  }
</style>
</head>
<body>

<div id="positioner">
  <canvas id="canvas"></canvas>

  <div id="scroller">
    <div id="sizer"></div>
  </div>
</div>

<script src="./utils.js"></script>
<script>
  const columnHeaders = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

  const COLORS = {
    background: {
      default: '#fff',
      fixedRow: '#f8f9fa',
      focused: '#eee9effdf',
      selected: '#e9effd',
      selectedFixed: '#d3e3fe',
    },
    border: {
      default: '#e1e1e1',
      fixedColumn: '#c0c0c0',
      fixedRow: '#c0c0c0',
      focused: '#1b73e8',
      selected: '#1b73e8',
    },
    text: {
      default: '#333',
      fixedColumn: '#888',
    },
  };

  let width = 800;
  let height = 400;

  const cellPadding = 4;
  const focusedCellOffset = 2;

  const scroller = document.getElementById('scroller');
  const canvas = document.getElementById('canvas');
  const context = canvas.getContext("2d");

  function scaleHelper() {
    const dpr = window.devicePixelRatio || 2

    const { width, height } = canvas.getBoundingClientRect()

    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
      canvas.width = width * dpr;
      canvas.height = height * dpr;
    }

    // Reset scale to identical matrix to allow multiple re-scales.
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.scale(dpr, dpr);
  }

  function resize() {
    height = window.innerHeight;
    width = window.innerWidth;

    canvas.style.height = `${height}px`
    canvas.style.width = `${width}px`;

    scroller.style.height = `${height}px`
    scroller.style.width = `${width}px`;

    scaleHelper();
  }

  resize();

  // TODO Handle resize

  function draw(grid) {
    const {
      focusedCell,
      getCellAtPosition,
      getCellData,
      getCellRect,
      numCols,
      numRows,
      offsetX,
      offsetY,
      selection
    } = grid;

    context.clearRect(0, 0, width, height);

    const modifyRectForOffsets = (rect) => {
      rect.x -= offsetX;
      rect.y -= offsetY;
      return rect;
    };

    const getColumnHeader = (columnIndex) => {
      let label = "";

      while (columnIndex >= 0) {
        label += columnHeaders[columnIndex % columnHeaders.length];

        columnIndex -= columnHeaders.length;
      }

      return label;
    };

    // TODO Only draw visible cells (requires tracking offsets)
    const topLeftCell = getCellAtPosition(offsetX, offsetY, true);
    const bottomRightCell = getCellAtPosition(offsetX + width, offsetY + height, true);
    const visibleBounds = {
      start: {
        columnIndex: topLeftCell.columnIndex,
        rowIndex: topLeftCell.rowIndex
      },
      stop: {
        columnIndex: bottomRightCell.columnIndex,
        rowIndex: bottomRightCell.rowIndex
      }
    };

    // Draw data cells
    for (
      let columnIndex = visibleBounds.start.columnIndex;
      columnIndex <= visibleBounds.stop.columnIndex;
      columnIndex++
    ) {
      for (
        let rowIndex = visibleBounds.start.rowIndex;
        rowIndex <= visibleBounds.stop.rowIndex;
        rowIndex++
      ) {
        const isSelected = selection && (
          rowIndex >= selection.start.rowIndex &&
          rowIndex <= selection.stop.rowIndex &&
          columnIndex >= selection.start.columnIndex &&
          columnIndex <= selection.stop.columnIndex
        );

        drawDataCell({
          columnIndex,
          context,
          mode: isSelected ? "selected" : "view",
          rect: modifyRectForOffsets(getCellRect(rowIndex, columnIndex)),
          rowIndex,
          text: getCellData(rowIndex, columnIndex),
        });
      }
    }

    // Draw selection outline above base grid
    if (selection) {
      const topLeftCell = modifyRectForOffsets(getCellRect(selection.start.rowIndex, selection.start.columnIndex));
      const bottomRightCell = modifyRectForOffsets(getCellRect(selection.stop.rowIndex, selection.stop.columnIndex));

      drawRect({
        context,
        rect: {
          height: bottomRightCell.y + bottomRightCell.height - topLeftCell.y,
          width: bottomRightCell.x + bottomRightCell.width - topLeftCell.x,
          x: topLeftCell.x,
          y: topLeftCell.y,
        },
        strokeStyle: COLORS.border.selected,
      });
    }

    // Draw focused cell on top of everything else
    if (focusedCell) {
      const { columnIndex, rowIndex } = focusedCell;
      const rect = modifyRectForOffsets(getCellRect(rowIndex, columnIndex));

      drawRect({
        boxSizing: "content-box",
        context,
        lineWidth: 2,
        rect: {
          height: rect.height,
          width: rect.width,
          x: rect.x,
          y: rect.y,
        },
        strokeStyle: COLORS.border.focused,
      });
    }

    // Draw fixed row headers
    for (
      let columnIndex = visibleBounds.start.columnIndex;
      columnIndex <= visibleBounds.stop.columnIndex;
      columnIndex++
    ) {
      drawFixedHeaderRow({
        context,
        isSelected: selection && selection.start.columnIndex <= columnIndex && selection.stop.columnIndex >= columnIndex,
        rect: {
          ...modifyRectForOffsets(getCellRect(-1, columnIndex)),
          y: 0,
        },
        text: columnIndex >= 0 ? getColumnHeader(columnIndex) : "",
      });
    }

    // Draw fixed column labels
    for (
      let rowIndex = visibleBounds.start.rowIndex;
      rowIndex <= visibleBounds.stop.rowIndex;
      rowIndex++
    ) {
      drawFixedColumnNumber({
        context,
        isSelected: selection && selection.start.rowIndex <= rowIndex && selection.stop.rowIndex >= rowIndex,
        rect: {
          ...modifyRectForOffsets(getCellRect(rowIndex, -1)),
          x: 0
        },
        text: rowIndex,
      });
    }

    drawRect({
      context,
      fillStyle: COLORS.background.fixedRow,
      rect: getCellRect(-1, -1),
      strokeSides: STROKE_SIDE_BOTTOM | STROKE_SIDE_RIGHT,
      strokeStyle: COLORS.border.fixedRow,
    });
  }

  function drawFixedColumnNumber({ context, isSelected, rect, text }) {
    drawRect({
      context,
      fillStyle: isSelected ? COLORS.background.selectedFixed : COLORS.background.default,
      rect,
      strokeSides: STROKE_SIDE_BOTTOM | STROKE_SIDE_RIGHT,
      strokeStyle: COLORS.border.fixedColumn,
    })

    fillTextHelper({
      context,
      fillStyle: COLORS.text.default,
      font: isSelected ? "8px sans-serif bold" : "8px sans-serif",
      padding: cellPadding,
      rect,
      text,
      textAlign: 'center',
    });
  }

  function drawFixedHeaderRow({ context, isSelected, rect, text }) {
    drawRect({
      context,
      fillStyle: isSelected ? COLORS.background.selectedFixed : COLORS.background.fixedRow,
      lineWidth: 1,
      rect,
      strokeSides: STROKE_SIDE_BOTTOM | STROKE_SIDE_RIGHT,
      strokeStyle: COLORS.border.fixedRow,
    });

    fillTextHelper({
      context,
      font: isSelected ? "10px sans-serif bold" : "10px sans-serif",
      padding: cellPadding,
      rect,
      text,
      textAlign: 'center',
    });
  }

  function drawDataCell({ columnIndex, context, mode, rect, rowIndex, text }) {
    let fillStyle;
    let lineWidth;
    let strokeStyle;

    switch (mode) {
      case 'focused': {
        fillStyle = COLORS.background.focused;
        lineWidth = 2;
        strokeStyle = COLORS.border.focused;
        break;
      }
      case 'selected': {
        fillStyle = COLORS.background.selected;
        lineWidth = 1;
        strokeStyle = COLORS.border.default;
        break;
      }
      case 'view': {
        fillStyle = COLORS.background.default;
        lineWidth = 1;
        strokeStyle = COLORS.border.default;
        break;
      }
      default: {
        throw `Unsupported mode "${mode}"`;
      }
    }

    drawRect({
      context,
      fillStyle,
      lineWidth,
      rect,
      strokeSides: STROKE_SIDE_BOTTOM | STROKE_SIDE_RIGHT,
      strokeStyle,
    });

    fillTextHelper({
      context,
      padding: cellPadding,
      rect,
      text,
      textAlign: 'right',
    });
  }

  function fillTextHelper({
    textBaseline = "middle",
    context,
    fillStyle = COLORS.text.default,
    font = "10px sans-serif",
    padding,
    rect,
    text,
    textAlign,
  }) {
    let {
      height,
      width,
      x,
      y,
    } = rect;

    while (text.length > 0) {
      const { width: measuredWidth } = context.measureText(text);

      if (measuredWidth > width - padding * 2) {
        text = text.substring(0, text.length - 1);
      } else {
        break;
      }
    }

    const verticalCenter = y + height / 2;

    context.font = font;
    context.textBaseline = textBaseline;
    context.fillStyle = fillStyle;

    switch (textAlign) {
      case "center": {
        context.textAlign = "center";
        context.fillText(text, x + width / 2, verticalCenter);
        break;
      }
      case "left": {
        context.textAlign = "left";
        context.fillText(text, x + padding, verticalCenter);
        break;
      }
      case "right": {
        context.textAlign = "right";
        context.fillText(text, x + width - padding, verticalCenter);
        break;
      }
      default: {
        throw `Unsupported alignment "${textAlign}"`;
      }
    }
  }

  {
    // Fake grid data for demo purposes

    const numRows = 10_000;
    const numCols = 100;

    const cellHeight = 20;
    const fixedCellWidth = 20;

    const randomData = new Array(numRows * numCols)
      .fill(true)
      .map(() => Math.round(Math.random() * 10_000));

    const randomCellWidths = new Array(numRows * numCols)
      .fill(true)
      .map(() => 50 + Math.round(Math.random() * 25));

    const totalWidth = new Array(numCols)
      .fill(true)
      .map((_, index) => index)
      .reduce((totalWidth, columnIndex) => {
        const width = randomCellWidths[columnIndex];

        return totalWidth + width;
      }, 0);

    let firstDragCell = null;
    let mostRecentDragCell = null;

    let offsetX = 0;
    let offsetY = 0;

    let focusedCell = null;
    let selection = null;

    const sizer = document.getElementById('sizer');
    sizer.style.height = `${cellHeight * numRows}px`
    sizer.style.width = `${totalWidth}px`;

    // Let the browser manage (elastic) scrolling for us
    scroller.addEventListener('scroll', (event) => {
      event.preventDefault();

      offsetX = scroller.scrollLeft;
      offsetY = scroller.scrollTop;

      redraw();
    });

    // TODO Separate event listeners from user config space
    // TODO Support keyboard navigation also

    scroller.addEventListener('pointerdown', (event) => {
      focusedCell = firstDragCell = getCellAtPosition(event.offsetX, event.offsetY);

      if (focusedCell) {
        selection = {
          start: focusedCell,
          stop: focusedCell,
        };
      }

      redraw();
    });

    scroller.addEventListener('pointermove', (event) => {
      // TODO Update selection when moving outside of canvas (or within fixed cells)

      if (firstDragCell) {
        const cell = getCellAtPosition(event.offsetX, event.offsetY);
        if (cell) {
          mostRecentDragCell = cell;

          // Re-calculate all selected cells based on start point and current point
          selection = {
            start: {
              columnIndex: Math.min(firstDragCell.columnIndex, mostRecentDragCell.columnIndex),
              rowIndex: Math.min(firstDragCell.rowIndex, mostRecentDragCell.rowIndex)
            },
            stop: {
              columnIndex: Math.max(firstDragCell.columnIndex, mostRecentDragCell.columnIndex),
              rowIndex: Math.max(firstDragCell.rowIndex, mostRecentDragCell.rowIndex)
            },
          };

          redraw();
        }
      }
    });

    scroller.addEventListener('pointerup', (event) => {
      firstDragCell = null;
      mostRecentDragCell = null;
    });

    window.addEventListener('pointerup', (event) => {
      firstDragCell = null;
      mostRecentDragCell = null;
    });

    function getCellSize(rowIndex, columnIndex) {
      return {
        height: cellHeight,
        width: columnIndex < 0 ? fixedCellWidth : randomCellWidths[columnIndex]
      };
    }

    function getCellAtPosition(x, y, findNearest) {
      let columnIndex = -1;
      let currentX = 0;
      while (true) {
        const { width } = getCellSize(0, columnIndex);

        currentX += width;

        if (currentX >= x && currentX + width >= x) {
          break;
        } else if (columnIndex === numCols - 1) {
          break;
        }

        columnIndex++;
      }

      const rowIndex = Math.min(numRows - 1, Math.floor(y / cellHeight) - 1);

      if (columnIndex < 0 || rowIndex < 0) {
        if (findNearest) {
          return {
            columnIndex: Math.max(columnIndex, 0),
            rowIndex: Math.max(rowIndex, 0)
          };
        } else {
          return null;
        }
      } else {
        return { columnIndex, rowIndex };
      }
    }

    function redraw() {
      draw({
        // TODO Cache computed cell offsets so we don't need to recalculate on every scroll
        getCellRect: (rowIndex, columnIndex) => {
          let width = columnIndex < 0 ? fixedCellWidth : randomCellWidths[columnIndex];

          let x = 0;
          for (let prevColumnIndex = -1; prevColumnIndex < columnIndex; prevColumnIndex++) {
            const { width } = getCellSize(0, prevColumnIndex);

            x += width;
          }

          return {
            height: cellHeight,
            width,
            x,
            y: (rowIndex + 1) * cellHeight
          };
        },
        getCellData: (rowIndex, columnIndex) => {
          const index = rowIndex * numCols + columnIndex;
          return randomData[index];
        },
        getCellAtPosition,
        focusedCell,
        numCols,
        numRows,
        offsetX,
        offsetY,
        selection,
      });
    }

    redraw();
  }
</script>
</body>
</html>